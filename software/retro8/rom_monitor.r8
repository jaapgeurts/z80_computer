unit rom_monitor

constants {

    // TODO: export these as EQU
    CTC_A  = 0x00
  // SIO_AD = 0x40
    SIO_BD = 0x41
  //  SIO_AC = 0x42
    SIO_BC = 0x43

    SIO_AC = 0x80
    SIO_AD = 0x81
}

variables {
    buf : ubyte[255]
}

extern {
}


function initTimer() {

/* Crystal is 3,686,400 MHz
  set up CTC  - 4800 baud is max achievable with 1MHz
  Time constants at 1MHz:
  26; time constant for 2400 baud, 0.16% error
  13; time constant for 4800 baud, 0.16% error
   baudrates - Time constant
   @3.686MHZ
  115200    - 2
  57600     - 4
  19200     - 12
  9600      - 24
*/
    #CTC_A := 0b00000101
    #CTC_A := 1
}

function initSerial() {
    // reset channel 0
    #SIO_AC := 0b00110000

    #SIO_AC := 0b00000100 // set clock rate, No parity, 1 stopbit
    #SIO_AC := 0b00000100 

    #SIO_AC := 0b00000011 // enable receiver (WR3)
    #SIO_AC := 0b11000001 // recv enable; 8bits / char

    #SIO_AC := 0b00000101 //
    #SIO_AC := 0b01101000 // send enable
}

function waitSerial() {
    asm {

  ; wait for serial port to be free
  ld	a, 0b00000000 ; write to WR1. Next byte is RR0
  out	(SIO_AC), a
wait_serial_again:
  in    a, (SIO_AC)
  bit   2,a
  jr    z, wait_serial_again

    }
}


function putChar(c : A!ubyte) {
    asm {
; put comment here in order to prevent swallowing whitespace
  push af
  call waitSerial  ; make sure we can send
  pop  af
  out  (SIO_AD), a
    }
}

function getChar() : A!ubyte {
    
    asm {
  ; check if character available
  ld   a, 0b00000000  ; write to WR1. Next byte is RR0
  out  (SIO_AC), a
  in   a,(SIO_AC)
  bit  0, a
  jr   nz,readchar    ; no char available
  ld   a,0            ; FIXME: should use word here since 0 is a valid character
  ret
readchar:
  in   a,(SIO_AD)     ; if yes, then read and return in a
  }
}


function readLine() {
    
    ch : H!ubyte
    c :  L!ubyte
    buffer : DE!ubyte[]
  
    buffer := buf
    buffer++ // skip string length

    loop {
        repeat {
            ch := getChar()
        } until ch != 0
        
        if (ch = '\r') {
           
           [buf] := c
           return
        }
        putChar(ch)
        if ch = '\b' {
            putChar(' ')
            putChar('\b')
        }
        else {
            [buffer] := ch
            buffer++;
        }
    }
}

function printk(m : HL!ubyte[]) {
    asm {
  ; print kernel message to serial (uses pascal strings)
  push hl
  ld   b,(hl)
printk_loop:
  call waitSerial
  inc  hl
  ld   a, (hl)
  out  (SIO_AD), a
  djnz printk_loop
  pop  hl
    }
}


function strcmp(s1 : HL!ubyte[], s2 : DE!ubyte[]) : A!bool {
    b : C!ubyte

    b := [s1]
    while b >= 0 {
        if [s1] != [s2] {
          return false
        }
        s1++
        s2++
        b--
    }
    return true
}

function main() {
    
    // Setup the timer
    initTimer()

    // First initialize the serial port
    initSerial()

    printk("Z80 ROM Monitor v0.1\r\n")
    printk("Written in r8");
    printk("(C) Jan-Feb 2021 Jaap Geurts\r\n");

    loop {
        // show prompt
        printk("> ")
        readLine() // result in buf

        if strcmp(buf,"help") {
            printk("Commands: help, halt, load, dump, run\r\n")
        }
    }

}